<!DOCTYPE html>
<html>
<head>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta charset=utf-8></head>
<body></body>
<script language=javascript>
;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var process=require("__browserify_process");var Canvas    = require('canvas-browserify')
var Vec2      = require('vec2')
var vecCanvas = require('./vec2-canvas')
var drawScale     = require('./scale')

function v (x, y) {
  return new Vec2(x, y)
}

function find (ary, test) {
  for(var i in ary)
    if(test(ary[i], i, ary))
      return ary[i]
}

/*
now, we can only support 2 scales, maximum.
(to be drawn on the left and the right side)
*/

function nColours (N, sat, light) {
  sat = sat || 100; light = light || 50
  var a = []
  for(var i = 0; i < N; i++) {
    console.log(i, 360/N)
    a.push('hsl('+ (i*(360/N)) + ', ' + sat + '%, ' + light +'%)')
  }
  return a
}

var graph = module.exports = function (canvas, table, opts) {
  var ctx = canvas.getContext('2d')
  opts = opts || {}
  table.sort()

  var colours = nColours(table.width() - 1, 100, 50)
  //['black', 'red', 'blue', 'green', 'yellow', 'orange', 'purple']

  var stats = table.stats()
  //calculate margin from font height
  var textHeight = parseInt(CTX.font)
  var margin = textHeight * 3

  var scales = {}, axis = []

  function defaultTo (n, v) {
    return n == null ? v : n
  }

  stats.forEach(function (stat, i) {
    if(!stat) return
    stat.min = 0
    stat.range = stat.max
    stat.title = table.header(i).name
    stat.units = table.header(i).units
    stat.color =
    stat.colour = colours[i - 1]

    if(i !== 0) {
      var scale = scales[stat.units] || {}
      scale.units = stat.units
      scale.min = Math.min(stat.min, defaultTo(scale.min,  Infinity))
      scale.max = Math.max(stat.max, defaultTo(scale.max, -Infinity))
      scale.range = scale.max - scale.min
      scales[scale.units] = scale
    }
  })

  axis[0] = stats[0]

  for(var u in scales)
    axis.push(scales[u])

  var stat = stats[0]
  var xScale = (canvas.width - margin*2) / (stat.max - stat.min)
  var xMin = stat.min

  var draw = vecCanvas(ctx)

  var j = 0

  //draw scale on the sides of the graph
  //drawing the actual graph is the easy bit.
  //but it's the scales that make it useful.

  function drawLabels (scale, side) {
    var opts = side || scale.side
    var min = opts.min, max = opts.max, align = opts.align
    var onSide = stats.filter(function (stat) {
      return stat.units === scale.units
    })

    var length = 0
    var labels = onSide.map(function (e) {
      var label = e.title
      length += ctx.measureText(label).width + 15
      return label
    })

    length += (onSide.length )*5 + ctx.measureText('('+scale.units+')').width

    var dir = v(max).subtract(min).normalize()
    var center =
      v(min).add(max).divide(2)
      .add(v(align).multiply((align.x > 0 ? textHeight*2 : textHeight*2.5)))

    var start = v(min)
      .add(v(align).multiply((align.x > 0 ? textHeight*2 : textHeight*2.5)))

    var space = v(dir).multiply(textHeight)
    var line  = v(dir).multiply(textHeight*2)
    
    draw.textAlign('left')

    labels.forEach(function (label, i) {
      var length = ctx.measureText(label).width
      console.log('label', label, onSide[i].colour, start)

      draw
        .text(label, start, {rotate: !!align.x})
  
      draw
        .start()
        .strokeStyle(onSide[i].colour)
        .move(start.add(v(dir).multiply(length)).add(space))
        .line(start.add(line))
        .stroke()

      start.add(space)

      //into position for next label
    })

    //draw.text('('+scale.units+')', start, {rotate: !!align.x})
  }

  var sides = [
    //bottom
    { min   : v(margin, canvas.height - margin),
      max   : v(canvas.width - margin, canvas.height - margin),
      align : v(0, 1)
    },
    //left
    { min   : v(margin, canvas.height - margin),
      max   : v(margin, margin),
      align : v(-1, 0)
    },
    //right
    { min   : v(canvas.width - margin, canvas.height - margin),
      max   : v(canvas.width - margin, margin),
      align : v(1, 0)
    }
  ]

  axis.forEach(function (scale, i) {
    scale.side = sides[i]
    drawScale(canvas.getContext('2d'), scale)
  })

  drawLabels(axis[1], sides[0])

  stats.forEach(function (stat, col) {
    if(!col) return
    var scale = scales[stat.units]

    if(!stat) return
    var yScale = (canvas.height - margin*2)/(scale.max - scale.min)
    var _x = 0, _y = 0
    ctx.beginPath()
    ctx.strokeStyle = stat.color
    table.forEach(function (row, n) {
      var value = row[col]
      if(isNaN(value)) return
      var y = margin + (value - stat.min)*yScale
      var x = margin + (row[0] - xMin)*xScale
      ;(n ? ctx.lineTo : ctx.moveTo).call(ctx, x, canvas.height - y)
    })
    ctx.stroke()
  })

  draw
    .fillStyle('black')
    .text(opts.title || "Graph o'Data", {x: canvas.width/2, y: textHeight * 2})
  
  return canvas
}

if(process.title === 'browser') {
  var canvas = CANVAS = Canvas()
  canvas.width = 1000
  canvas.height = 600
  var ctx = CTX = canvas.getContext('2d')
  var createTable = require('dat-table').createTable
  graph(canvas, createTable(require('./test/fib.json')), {title: 'fib generators'})
  document.body.appendChild(canvas)
}

},{"./scale":7,"./test/fib.json":8,"./vec2-canvas":9,"__browserify_process":10,"canvas-browserify":2,"dat-table":4,"vec2":6}],2:[function(require,module,exports){

var Canvas = module.exports = function Canvas (w, h) {
  var canvas = document.createElement('canvas')
  canvas.width = w || 300
  canvas.height = h || 150
  return canvas
}

Canvas.Image = function () {
  var img = document.createElement('img')
  return img
}




},{}],3:[function(require,module,exports){
var _spaces = '                                       ';

function isNumber (n) {
  return 'number' === typeof n
}

function isObject (o) {
  return o && 'object' === typeof o
}

function isString (s) {
  return 'string' === typeof s
}

function isDecimal (e) {
  return isNumber(e) ? (e % 1 !== 0) : false
}

function isExponent (e) {
  return isNumber(e) && !isWeird(e) && (Math.abs(e) >= 1e21 || Math.abs(e) < 1e-6 && e !== 0)
}

function isWeird (n) {
  return isNumber(n) && (n === Infinity || n === -Infinity || isNaN(n))
}


function spaces (n) {
  return _spaces.substring(0, n)
}

function pad (value, length) {
  var string = value.toString()
  var total = Math.max(length.total, length.fraction + length.whole)

  if(isNumber(value) && !isWeird(value)) {
    var whole
    if(isExponent(value)) {
      whole = string.indexOf('e')
    } else
      whole = Math.round(value).toString().length
    string = spaces(total - whole - length.fraction) + value
    return  string + spaces(total - string.length)
  }
  var padding = spaces(total - string.length)
  return string + padding
}


module.exports = function (array) {
  function headerToString (e) {
    return e.name + (e.units ? ' (' + e.units + ')' : '')
  }
  
  function reduceLengths (l, item) {
    if(!l) l = {whole: 0, total: 0, fraction: 0}
    var whole, fraction, total
    if(isNumber(item)) {
      if(isExponent(item)) {
        var str = item.toString()
        whole = str.indexOf('e')
        fraction = str.length - whole
        total = str.length
      } else if(isDecimal(item)) {
        var string = item.toString()
        whole = string.indexOf('.')
        fraction = string.substring(whole).length
        console.log(string, whole, fraction)
        total = string.length
      } else {
        total = whole = item.toString().length
        fraction = 0
      }
    } else {
      total = item.toString().length
      fraction = whole = 0
    }
    
    l.total = Math.max(l.total, total)
    l.whole = Math.max(l.whole, whole)
    l.fraction = Math.max(l.fraction, fraction)

    return l
  }

  var lengths = []
  array[0] = array[0].map(headerToString)
  var lengths = array.reduce(function (a, line) {
      line.forEach(function (v, i) {
        a[i] = reduceLengths(a[i], v)
      })
      return a
    }, [])

  return array.map(function (e, i) {
    return e.map(function (e, i) {
      return pad(e, lengths[i])
    }).join(', ').trimRight()
  }).join('\n')

}

},{}],4:[function(require,module,exports){
module.exports = Table
var format = require('./format')

function isNumber (n) {
  return 'number' === typeof n
}

function isObject (o) {
  return o && 'object' === typeof o
}

function isString (s) {
  return 'string' === typeof s
}

//function isDecimal (e) {
//  return isNumber(e) ? (e % 1 !== 0) : false
//}
//
//function isExponent (e) {
//  return Math.abs(e) >= 1e21 || Math.abs(e) < 1e-6
//}
//

function parseUnits (header) {
  if(isObject(header)) return header
  var m = /^(.+)\s+\(([^\)]+)\)$/.exec(header.trim())
  if(!m) return {name: header.trim()}
  return {name: m[1].trim(), units: m[2]}
}

function Table (headers) {
  if(!(this instanceof Table)) return new Table(headers)
  this._rows = []
  this._columns = []
  this._headers = headers.map(parseUnits)

  var self = this
  this._headers.forEach(function (header, i) {
    self._columns[i] = new Column(self, i, header)
  })
}

var t = Table.prototype

t.getRow = function (row) {
  return this._rows[i]
}

t.addRow = function (array) {
  this._rows.push(array)
  return this
}

t.units = function (i) {
  if(isNumber(i))
    return this._headers[i].units
  return this._headers.map(function (e) { return e.units })
}

t.header = function (i) {
  if(isNumber(i))
    return this._headers[i]
  return this._headers.slice()

}

module.exports.createTable = function (data, opts) {
  //first row is headers, unless opts says otherwise (todo)
  //array of arrays

  //parse CSV. naive, does not handle quotes yet.
  if(isString(data))
    data = data
    .split('\n')
    .filter(function (e) { return !!e})
    .map(function (e) {
      return e.split(',').map(function (e) {
        var value = e.trim()
        return isNaN(value) ? value : parseFloat(value)
      })
    })

  var t = new Table(data[0])

  for(var i = 1; i < data.length; i++)
    t.addRow(data[i].map(function (e) {
      return isString(e) ? e.trim() : e
    }))

  return t
}

//okay, so what about operations like min and max?
//average or sum? something calculated across a column?

t.column = function (n) {
  if(!this._headers[n])
    throw new Error('table does not have column:' + n)
  return this._columns[n] = this._columns[n] || new Column(this, n)
}

t.reduce = function (col, reducer, initial) {
  if('function' == typeof col) {
    initial = reducer, reducer = col, col = null
    var a = []
    for(var i = 0; i < this.width(); i++)
      a[i] = this.reduce(i, reducer, initial)
    return a
  }
  var acc = initial || null
  for(var i = 0; i < this._rows.length; i++) {
    if(this._rows[i].hasOwnProperty(col))
      acc = reducer(acc, this._rows[i][col])
  }
  return acc
}

t.length = function () {
  return this._rows.length
}

t.width = function () {
  return this._columns.length
}
t.sort =
t.sortBy = function (col, comparator) {
  if('function' === typeof col)
    comparator = col, col = 0
  col = col || 0
  this._rows.sort(function (a, b) {
    var _a = a[col], _b = b[col]
    if(comparator) return comparator(_a, _b)
    return _a == _b ? 0 : _a < _b ? -1 : 1
  })
  return this
}
t.forEach =
t.each = function (col, iter) {
  if('function' === typeof col)
    iter = col, col = null
  var l = this.length()

  if(col == null)
    for(var i = 0; i < l; i++)
      iter(this._rows[i], i, this)
  else
    for(var i = 0; i < l; i++)
      if(this._rows[i].hasOwnProperty(col))
        iter(this._rows[i][col], i, this)
}

t.toJSON = function () {
  var a = []
  a.push(this._headers.slice())
  this.each(function (row) {
    a.push(row.slice())
  })
  return a
}

t.toCSV =
t.toString = function () {
  return format(this.toJSON())
}


var stats = require('./stats')

for(var k in stats)
  (function (k) {
    t[k] = function (i) {
      if(i == null)
        return this.reduce(stats[k])
      return this.reduce(i, stats[k])
    }
  })(k)

//this does nothing currently...
//but maybe it would be good to have something like this?
//so that you can pass columns to functions?
function Column (table, header, i) {
  this._table = table, this._header = header, this._i = i
}


},{"./format":3,"./stats":5}],5:[function(require,module,exports){


function isNumber (n) {
  return 'number' === typeof n
}

exports.stats = function (stat, e) {

  if(!isNumber(e))
    return stat

  if(stat == null)
    stat = {sum: e, count: 1, mean: e, min: e, max: e}
  else {
    stat.sum += e
    stat.count ++
    stat.min = Math.min(e, stat.min)
    stat.max = Math.max(e, stat.max)
    stat.range = stat.max - stat.min
    stat.mean = stat.sum / stat.count
    //I don't recall how to calculate stddev in a single pass...
    //look this up.
  }

  return stat
}

exports.sum = function (sum, e) {
  return (sum || 0) + e
}

exports.max = function (max, e) {
  if(!isNumber(e)) return max
  if(max == null) return e
  return Math.max(max, e)
}

exports.min = function (min, e) {
  if(!isNumber(e)) return min
  if(min == null) return e
  return Math.min(min, e)
}

exports.count = function (c, e) {
  return (c || 0) + 1
}


},{}],6:[function(require,module,exports){
;(function inject(clean, precision, undef) {

  function Vec2(x, y) {
    if (!(this instanceof Vec2)) {
      return new Vec2(x, y);
    }

    if('object' === typeof x && x) {
      this.y = x.y || 0;
      this.x = x.x || 0;
      return
    }

    this.x = Vec2.clean(x || 0);
    this.y = Vec2.clean(y || 0);
  };

  Vec2.prototype = {
    change : function(fn) {
      if (fn) {
        if (this.observers) {
          this.observers.push(fn);
        } else {
          this.observers = [fn];
        }
      } else if (this.observers) {
        for (var i=this.observers.length-1; i>=0; i--) {
          this.observers[i](this);
        }
      }

      return this;
    },

    ignore : function(fn) {
      this.observers = this.observers.filter(function(cb) {
        return cb !== fn;
      });

      return this;
    },

    dirty : function() {
      this._dirty = true
      this.__cachedLength = null
      this.__cachedLengthSquared = null
    },

    // set x and y
    set: function(x, y, silent) {
      if('number' != typeof x) {
        silent = y;
        y = x.y;
        x = x.x;
      }
      if(this.x === x && this.y === y)
        return this;

      this.x = Vec2.clean(x);
      this.y = Vec2.clean(y);

      this.dirty()
      if(silent !== false)
        return this.change();
    },

    // reset x and y to zero
    zero : function() {
      return this.set(0, 0);
    },

    // return a new vector with the same component values
    // as this one
    clone : function() {
      return new Vec2(this.x, this.y);
    },

    // negate the values of this vector
    negate : function(returnNew) {
      if (returnNew) {
        return new Vec2(-this.x, -this.y);
      } else {
        return this.set(-this.x, -this.y);
      }
    },

    // Add the incoming `vec2` vector to this vector
    add : function(vec2, returnNew) {
      if (!returnNew) {
        this.x += vec2.x; this.y += vec2.y;
        return this.change()
      } else {
        // Return a new vector if `returnNew` is truthy
        return new Vec2(
          this.x + vec2.x,
          this.y + vec2.y
        );
      }
    },

    // Subtract the incoming `vec2` from this vector
    subtract : function(vec2, returnNew) {
      if (!returnNew) {
        this.x -= vec2.x; this.y -= vec2.y;
        return this.change()
      } else {
        // Return a new vector if `returnNew` is truthy
        return new Vec2(
          this.x - vec2.x,
          this.y - vec2.y
        );
      }
    },

    // Multiply this vector by the incoming `vec2`
    multiply : function(vec2, returnNew) {
      var x,y;
      if ('number' !== typeof vec2) { //.x !== undef) {
        x = vec2.x;
        y = vec2.y;

      // Handle incoming scalars
      } else {
        x = y = vec2;
      }

      if (!returnNew) {
        return this.set(this.x * x, this.y * y);
      } else {
        return new Vec2(
          this.x * x,
          this.y * y
        );
      }
    },

    // Rotate this vector. Accepts a `Rotation` or angle in radians.
    //
    // Passing a truthy `inverse` will cause the rotation to
    // be reversed.
    //
    // If `returnNew` is truthy, a new
    // `Vec2` will be created with the values resulting from
    // the rotation. Otherwise the rotation will be applied
    // to this vector directly, and this vector will be returned.
    rotate : function(r, inverse, returnNew) {
      var
      x = this.x,
      y = this.y,
      cos = Math.cos(r),
      sin = Math.sin(r),
      rx, ry;

      inverse = (inverse) ? -1 : 1;

      rx = cos * x - (inverse * sin) * y;
      ry = (inverse * sin) * x + cos * y;

      if (returnNew) {
        return new Vec2(rx, ry);
      } else {
        return this.set(rx, ry);
      }
    },

    // Calculate the length of this vector
    length : function() {
      var x = this.x, y = this.y;
      return Math.sqrt(x * x + y * y);
    },

    // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
    lengthSquared : function() {
      var x = this.x, y = this.y;
      return x*x+y*y;
    },

    // Return the distance betwen this `Vec2` and the incoming vec2 vector
    // and return a scalar
    distance : function(vec2) {
      var x = this.x - vec2.x;
      var y = this.y - vec2.y;
      return Math.sqrt(x*x + y*y)
    },

    // Convert this vector into a unit vector.
    // Returns the length.
    normalize : function(returnNew) {
      var length = this.length();

      // Collect a ratio to shrink the x and y coords
      var invertedLength = (length < Number.MIN_VALUE) ? 0 : 1/length;

      if (!returnNew) {
        // Convert the coords to be greater than zero
        // but smaller than or equal to 1.0
        return this.set(this.x * invertedLength, this.y * invertedLength);
      } else {
        return new Vec2(this.x * invertedLength, this.y * invertedLength)
      }
    },

    // Determine if another `Vec2`'s components match this one's
    // also accepts 2 scalars
    equal : function(v, w) {
      if (w === undef) {
        return (
          this.x === v.x &&
          this.y == v.y
        );
      } else {
        return (
          this.x === v &&
          this.y === w
        )
      }
    },

    // Return a new `Vec2` that contains the absolute value of
    // each of this vector's parts
    abs : function(returnNew) {
      var x = Math.abs(this.x), y = Math.abs(this.y);

      if (returnNew) {
        return new Vec2(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the smallest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    min : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx < vx ? tx : vx,
      y = ty < vy ? ty : vy;

      if (returnNew) {
        return new Vec2(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the largest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    max : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx > vx ? tx : vx,
      y = ty > vy ? ty : vy;

      if (returnNew) {
        return new Vec2(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Clamp values into a range.
    // If this vector's values are lower than the `low`'s
    // values, then raise them.  If they are higher than
    // `high`'s then lower them.
    //
    // Passing returnNew as true will cause a new Vec2 to be
    // returned.  Otherwise, this vector's values will be clamped
    clamp : function(low, high, returnNew) {
      var ret = this.min(high, true).max(low)
      if (returnNew) {
        return ret;
      } else {
        return this.set(ret.x, ret.y);
      }
    },

    // Perform linear interpolation between two vectors
    // amount is a decimal between 0 and 1
    lerp : function(vec, amount) {
      return this.add(vec.subtract(this, true).multiply(amount), true);
    },

    // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
    skew : function() {
      // Returns a new vector.
      return new Vec2(-this.y, this.x)
    },

    // calculate the dot product between
    // this vector and the incoming
    dot : function(b) {
      return Vec2.clean(this.x * b.x + b.y * this.y);
    },

    // calculate the perpendicular dot product between
    // this vector and the incoming
    perpDot : function(b) {
      return Vec2.clean(this.x * b.y - this.y * b.x)
    },

    // Determine the angle between two vec2s
    angleTo : function(vec) {
      return Math.atan2(this.perpDot(vec), this.dot(vec));
    },

    // Divide this vector's components by a scalar
    divide : function(scalar, returnNew) {
      if (scalar === 0 || isNaN(scalar)) {
        throw new Error('division by zero')
      }

      if (returnNew) {
        return new Vec2(this.x/scalar, this.y/scalar);
      }

      return this.set(this.x / scalar, this.y / scalar);
    },

    isPointOnLine : function(start, end) {
      return (start.y - this.y) * (start.x - end.x) ===
             (start.y - end.y) * (start.x - this.x);
    },

    toArray: function() {
      return [this.x, this.y];
    },

    fromArray: function(array) {
      return this.set(array[0], array[1]);
    },
    toJSON: function () {
      return {x: this.x, y: this.y}
    }
  };

  Vec2.fromArray = function(array) {
    return new Vec2(array[0], array[1]);
  };

  // Floating point stability
  Vec2.precision = precision || 8;
  var p = Math.pow(10, Vec2.precision)

  Vec2.clean = clean || function(val) {
    if (isNaN(val)) {
      throw new Error('NaN detected')
    }

    if (!isFinite(val)) {
      throw new Error('Infinity detected');
    }

    if(Math.round(val) === val) {
      return val;
    }

    return Math.round(val * p)/p;
  };

  Vec2.inject = inject;

  if(!clean) {
    Vec2.fast = inject(function (k) { return k })

    // Expose, but also allow creating a fresh Vec2 subclass.
    if (typeof module !== 'undefined' && typeof module.exports == 'object') {
      module.exports = Vec2;
    } else {
      window.Vec2 = window.Vec2 || Vec2;
    }
  }
  return Vec2
})();



},{}],7:[function(require,module,exports){
var vec2Draw = require('./vec2-canvas')
var Vec2 = require('vec2')

function v (x, y) {
  return new Vec2(x, y)
}

module.exports = drawScale
drawScale.steps = steps

function calcSteps (min, max, room, width) {
  var range = max - min
  var i = 0, e
  console.log('mMrw', min, max, room, width)
  while(true) {
    var e = Math.pow(10, i++)
    if(e > 10000000000)
      throw new Error('oops')
    if(room   / (range / e) > width*3) return e
    if(room*2 / (range / e) > width*3) return e*2
    if(room*5 / (range / e) > width*3) return e*5
  }
}

//must have range, room, and
function steps (min, max, opts, each) {
  var range = max - min
  var step = calcSteps(min, max, opts.room, opts.width)
  for(var i = 0; i*step < range; i++) {
    each(i*step)
  }
}

/*
A WWAAAAYYY easier approach.
draw everything straight up and starting from zero.
then translate/rotate to that point before you draw it.

you just have to remember to pop the state again...
it would be interesting if you could create independent drawing contexts,
but you can't...
*/

function ruler (ctx, length, nRotate, min, max) {
  var textHeight = parseInt(CTX.font)
  var draw = vec2Draw(ctx)
  nRotate = nRotate || 0
  draw
    .start()
    .move({x:0, y:0})
    .line({x:length, y:0})
    .stroke()

  var i = 0
  var range = max - min
  var scale = length/range
  var step = calcSteps(min, max, length, ctx.measureText(max).width)
  for(var i = 0; i < range*step; i++) {
    ctx.save()
    ctx.translate(i*step*scale, 0)
    if(nRotate)
      ctx.rotate(nRotate)
    draw
      .move({x:0, y:0})
      .line({x:0, y:textHeight/2})
      .textAlign('center')
      .text(i*step, {x:0, y: textHeight * 1.5})
      .stroke()
    ctx.restore()
  }
}
var T = 0
function drawScale (ctx, scale, opts) {
//  if(T++) return
//  ctx.save()
//  ctx.translate(Math.round(scale.side.min.x), Math.round(scale.side.min.y))
//  ruler(ctx,
//    v(scale.side.min).subtract(scale.side.max).length(), 
//    0, scale.min, scale.max)
//  ctx.restore()
//
//  ctx.save()
//  ctx.translate(Math.round(scale.side.min.x), Math.round(scale.side.min.y))
//  ctx.rotate(Math.PI*-0.5)
//  ruler(ctx, v(scale.side.min).subtract(scale.side.max).length(), Math.PI, scale.min, scale.max)
//  ctx.restore()

//  return //
  var draw = vec2Draw(ctx)
  opts = opts || {}
  var textHeight = parseInt(CTX.font)
  var side = scale.side || opts.side
  var log = opts.log

  function toScale (value) {
    return log ? Math.pow(Math.E, value) : value
  }

  function round (n) {
    return parseFloat(toScale(n).toPrecision(opts.precision || 3))
  }

  var min = side.min, max = side.max, align = side.align
  draw.strokeStyle('black').fillStyle('black').start().move(min).line(max)  

  var textWidth = ctx.measureText(round(scale.max)).width
  var textSize = align.x ? textHeight : textWidth

  var room   = v(max).subtract(min).length()
  var vec    = v(max).subtract(min).normalize()
  var offset = v(align).multiply((align.x > 0 ? textHeight : textHeight*1.5))
  var dash   = v(align).multiply(5)
  var markV  = v()
  var textV = v()

  //how many marks can fit on the graph?
  //if it's linear, that is simple
  //if it's logarithmic, that is a little more complex.
  //for now, we only support powers of 10 on the scale.
  var xScale = room/(scale.max - scale.min)
  //figure out step size for linear axis

  steps(scale.min, scale.max, {room:room, width:textWidth}, function (value) {
    markV.set(vec).multiply(value*xScale).add(min)
    draw
      .textAlign('center')
      .text(
        round(scale.min + value),
        textV.set(markV).add(offset),
        {rotate: !!align.x} //90 degrees
      )
      .move(markV)
      .line(markV.add(dash))
  })

  //maybe this should be completely separate?

  var label = (scale.title || '') + (scale.units ? ' (' + scale.units + ')' : '')
  if(label) {
    draw.text(
      label,
      v(min).add(max).divide(2).add(v(align).multiply((align.x > 0 ? textHeight*2 : textHeight*2.5))),
      {rotate: !!align.x}
    )
  }

  draw.stroke()
}


},{"./vec2-canvas":9,"vec2":6}],8:[function(require,module,exports){
module.exports=[
  [
    {
      "name": "N",
      "units": "N"
    },
    {
      "name": "Naive",
      "units": "ops/ms"
    },
    {
      "name": "Memoized",
      "units": "ops/ms"
    },
    {
      "name": "AvoidLookups",
      "units": "ops/ms"
    },
    {
      "name": "Random",
      "units": "ops/ms"
    }
  ],
  [
    1,
    17344.68,
    16193.39,
    16793.78,
    14784.54
  ],
  [
    2,
    16528.78,
    15937.2,
    16689,
    14519.41
  ],
  [
    3,
    14337.2,
    15749.57,
    16109.17,
    13734.97
  ],
  [
    4,
    12189.2,
    15729.71,
    15941.3,
    13626.41
  ],
  [
    5,
    9062.78,
    15781.34,
    15907.28,
    13508.6
  ],
  [
    6,
    6397.01,
    15770.23,
    15747.43,
    12991.16
  ],
  [
    7,
    4277.57,
    15759.7,
    15935.53,
    13424.57
  ],
  [
    8,
    2829.9,
    15752.68,
    15953.2,
    13490.57
  ],
  [
    9,
    1834.87,
    15782.13,
    15951.09,
    13497.28
  ],
  [
    10,
    1165.35,
    15745.41,
    15923.64,
    13254.52
  ],
  [
    11,
    731.48,
    15727.49,
    15951.89,
    13466.52
  ],
  [
    12,
    455.25,
    15766.73,
    15937.77,
    13460.8
  ],
  [
    13,
    284.93,
    15712.4,
    15958.17,
    13406.22
  ],
  [
    14,
    167.31,
    15776.48,
    15937.44,
    13470.13
  ],
  [
    15,
    109.61,
    15771.44,
    15927.99,
    13417.94
  ],
  [
    16,
    67.84,
    15771.55,
    15926.61,
    13476.94
  ],
  [
    17,
    41.59,
    15757.99,
    15962.09,
    13485.56
  ],
  [
    18,
    25.95,
    15711.01,
    15956.9,
    13308.68
  ],
  [
    19,
    16.03,
    15761.84,
    15934.43,
    13488.73
  ],
  [
    20,
    9.92,
    15769.51,
    15941.89,
    13408.31
  ],
  [
    21,
    6.14,
    15724.51,
    15961.39,
    13489.21
  ],
  [
    22,
    3.77,
    15725.46,
    15951.63,
    13484.84
  ],
  [
    23,
    2.34,
    15664.55,
    15934.25,
    13395.84
  ],
  [
    24,
    1.45,
    15696.08,
    15955.18,
    13497.97
  ],
  [
    25,
    0.9,
    15684.24,
    15900.04,
    13442.19
  ],
  [
    26,
    0.5544554455445545,
    15728.87,
    15946.02,
    13367.6
  ],
  [
    27,
    0.34,
    15743.98,
    15963.14,
    13500.2
  ],
  [
    28,
    0.21153846153846154,
    15646.88,
    15935.84,
    13507.09
  ],
  [
    29,
    0.1308411214953271,
    15550.7,
    15862.39,
    13489.74
  ],
  [
    30,
    0.08108108108108109,
    15664.66,
    15869.31,
    13492.98
  ],
  [
    31,
    0.05,
    15744.21,
    15929.72,
    13503.58
  ],
  [
    32,
    0.03076923076923077,
    15698.74,
    15945.2,
    13491.69
  ],
  [
    33,
    0.01904761904761905,
    15704.88,
    15886.96,
    13424.46
  ],
  [
    34,
    0.011764705882352941,
    15758.83,
    15925.97,
    13516.11
  ],
  [
    35,
    0.0072992700729927005,
    15610.65,
    15679.94,
    13509.55
  ],
  [
    36,
    0.0045662100456621,
    15842.09,
    15938.9,
    13466.95
  ],
  [
    37,
    0.002770083102493075,
    15766.21,
    15904.14,
    13510.42
  ],
  [
    38,
    0.001718213058419244,
    15491.27,
    15945.52,
    13459.63
  ],
  [
    39,
    0.0010570824524312897,
    15712.46,
    15904.98,
    13502.82
  ],
  [
    40,
    0.00065359477124183,
    15612.21,
    15399.68,
    13499.33
  ]
]

},{}],9:[function(require,module,exports){
function r (v) {
  return Math.round(v)
}

module.exports =
  function vecDraw (ctx) {
    if(ctx.getContext) //check if a canvas was passed in
      ctx = ctx.getContext('2d')
    return {
      text: function (string, vec, opts) {
        if(opts && opts.rotate === true) {
          ctx.save();
          ctx.translate(r(vec.x), r(vec.y))
          ctx.rotate(Math.PI/2)
          ctx.fillText(string, 0, 0);
          ctx.restore(); return this
        }
        ctx.fillText(string, vec.x, vec.y); return this
      },
      textAlign: function (style) {
        if(!arguments.length) return ctx.textAlign
        ctx.textAlign = style; return this
      },
      move: function (vec) {
        ctx.moveTo(r(vec.x), r(vec.y)); return this
      },
      line: function (vec) {
        ctx.lineTo(r(vec.x), r(vec.y)); return this
      },
      start: function () {
        ctx.beginPath(); return this
      },
      stroke: function () {
        ctx.stroke(); return this
      },
      strokeStyle: function (style) {
        if(!arguments.length) return ctx.strokeStyle
        ctx.strokeStyle = style; return this
      },
      fillStyle: function (style) {
        if(!arguments.length) return ctx.fillStyle
        ctx.fillStyle = style; return this
      },
    }
  }


},{}],10:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
;</script>
</html>
